import*as fields from"../../common/data/fields.mjs";import LevelDatabase from"./backend/level-database.mjs";import*as sanitization from"./sanitization.mjs";import EmbeddedDeltaMixin from"./backend/embedded-delta.mjs";import{randomID}from"../../common/utils/helpers.mjs";fields.HTMLField.prototype.sanitize=sanitization.sanitizeHTMLField,fields.FilePathField.prototype.sanitize=sanitization.sanitizeFilePathField,fields.EmbeddedCollectionField.prototype.sanitize=sanitization.sanitizeEmbeddedCollectionField,fields.EmbeddedDocumentField.prototype.sanitize=sanitization.sanitizeEmbeddedDocumentField,fields.DocumentOwnershipField.prototype.sanitize=sanitization.sanitizeDocumentOwnershipField,fields.DocumentAuthorField.prototype.sanitize=sanitization.sanitizeDocumentAuthorField,Object.defineProperty(fields.EmbeddedCollectionDeltaField.prototype,"model",{get(){return EmbeddedDeltaMixin(this.element.implementation)},configurable:!0}),fields.EmbeddedCollectionField.prototype.expandEmbedded=async function(e,t,i,d){const{logger:n}=global,o=LevelDatabase.formatKey(i,this.name),a=d.sublevels[o],l=e[this.name];if(!l)return[];if(!Array.isArray(l))return n.warn(`Did not retrieve ${this.name} collection from ${this.model.documentName} ${e._id} as it was not an Array.`),[];const s=l.map((e=>LevelDatabase.formatKey(t,e))),r=await a.getMany(s),m=await Promise.all(r.reduce(((e,i)=>(i?._id&&e.push(this.model.expandEmbedded(i,{ldb:d,idPrefix:t,sublevelName:o})),e)),[])),b=r.length-m.length;return b&&n.warn(`${b} embedded ${this.name} records in ${this.model.documentName} ${e._id} were undefined and not retrieved from the ${o} sublevel.`),m},fields.EmbeddedCollectionField.prototype._dbWrite=function(e,t,i,d,{writeEmbedded:n=!0,generateIds:o=!1}={}){const{logger:a}=global,l=LevelDatabase.formatKey(d,this.name),s=e[this.name];return s?Array.isArray(s)?s.reduce(((d,s)=>{if(!s._id){if(!o)return a.warn(`Did not write record in ${this.name} collection for ${this.model.documentName} ${e._id} as it had no ID.`),d;s._id=randomID()}return n&&this.model.batchWrite(s,t,{writeEmbedded:n,idPrefix:i,sublevelName:l}),d.push(s._id),d}),[]):(a.warn(`Did not write ${this.name} collection for ${this.model.documentName} ${e._id} as it was not an Array.`),[]):[]},fields.EmbeddedCollectionField.prototype._dbDelete=function(e,t,i,d){const n=LevelDatabase.formatKey(d,this.name),o=e[this.name];for(const e of o??[])this.model.batchDelete(e,t,{idPrefix:i,sublevelName:n})},fields.EmbeddedCollectionField.prototype._dbDeleteBranch=function(e,t,i){const d=e.getEmbeddedCollection(this.name);for(const e of d)e.batchDelete(t,i)},fields.EmbeddedCollectionDeltaField.prototype._dbDeleteBranch=function(e,t,i){const d=e.getEmbeddedCollection(this.name);for(const n of d._source)d.isTombstone(n._id)?d.documentClass.batchDelete(n,t,{idPrefix:e.dbKey,sublevelName:LevelDatabase.formatKey(e.sublevelName,this.name)}):d.get(n._id).batchDelete(t,i)},fields.EmbeddedDocumentField.prototype.expandEmbedded=async function(e,t,i,d){const{logger:n}=global,o=LevelDatabase.formatKey(i,this.name),a=d.sublevels[o];let l=e[this.name];if(!l)return null;l=LevelDatabase.formatKey(t,l);const s=await a.get(l);return s?(await this.model.expandEmbedded(s,{ldb:d,idPrefix:t,sublevelName:o}),s):(n.warn(`Singleton embedded ${this.name} ${l} in ${this.model.documentName} ${e._id} was undefined and not retrieved from the ${o} sublevel.`),null)},fields.EmbeddedDocumentField.prototype._dbWrite=function(e,t,i,d,{writeEmbedded:n=!0,generateIds:o=!1}={}){const{logger:a}=global,l=LevelDatabase.formatKey(d,this.name),s=e[this.name];if(!s)return null;if(!s._id){if(!o)return a.warn(`Did not write record in ${this.name} field for ${this.model.documentName} ${e._id} as it had no ID.`),null;s._id=randomID()}return n&&this.model.batchWrite(s,t,{writeEmbedded:n,idPrefix:i,sublevelName:l}),s._id},fields.EmbeddedDocumentField.prototype._dbDelete=function(e,t,i,d){const n=LevelDatabase.formatKey(d,this.name),o=e[this.name];o&&this.model.batchDelete(o,t,{idPrefix:i,sublevelName:n})};